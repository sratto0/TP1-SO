<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>view.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is a personal academic project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++, C#, and Java:</a>
<a name="ln3">// https://pvs-studio.com</a>
<a name="ln4"> </a>
<a name="ln5">#include &quot;view.h&quot;</a>
<a name="ln6">#include &lt;ncurses.h&gt;</a>
<a name="ln7">#include &lt;unistd.h&gt;</a>
<a name="ln8"> </a>
<a name="ln9">// Colores para el tablero</a>
<a name="ln10">#define COLOR_PAIR_BOARD 1</a>
<a name="ln11">#define COLOR_PAIR_NUMBER 2</a>
<a name="ln12">#define COLOR_PAIR_PLAYER1 3</a>
<a name="ln13">#define COLOR_PAIR_PLAYER2 4</a>
<a name="ln14">#define COLOR_PAIR_PLAYER3 5</a>
<a name="ln15">#define COLOR_PAIR_TITLE 6</a>
<a name="ln16">#define COLOR_PAIR_INFO 7</a>
<a name="ln17"> </a>
<a name="ln18">// Función para obtener el color del jugador</a>
<a name="ln19">int get_player_color(int player_id) {</a>
<a name="ln20">  switch (player_id) {</a>
<a name="ln21">  case 0:</a>
<a name="ln22">    return COLOR_PAIR_PLAYER1;</a>
<a name="ln23">  case 1:</a>
<a name="ln24">    return COLOR_PAIR_PLAYER2;</a>
<a name="ln25">  case 2:</a>
<a name="ln26">    return COLOR_PAIR_PLAYER3;</a>
<a name="ln27">  default:</a>
<a name="ln28">    return COLOR_PAIR_PLAYER1;</a>
<a name="ln29">  }</a>
<a name="ln30">}</a>
<a name="ln31"> </a>
<a name="ln32">// Función para verificar si un jugador está bloqueado</a>
<a name="ln33">bool is_player_blocked(game_t *game, unsigned int player_id) {</a>
<a name="ln34">  // Un jugador está bloqueado si no tiene movimientos válidos disponibles</a>
<a name="ln35">  int x = game-&gt;players[player_id].x;</a>
<a name="ln36">  int y = game-&gt;players[player_id].y;</a>
<a name="ln37"> </a>
<a name="ln38">  // Direcciones: arriba, abajo, izquierda, derecha</a>
<a name="ln39">  int dx[] = {0, 0, -1, 1};</a>
<a name="ln40">  int dy[] = {-1, 1, 0, 0};</a>
<a name="ln41"> </a>
<a name="ln42">  for (int i = 0; i &lt; 4; i++) {</a>
<a name="ln43">    int new_x = x + dx[i];</a>
<a name="ln44">    int new_y = y + dy[i];</a>
<a name="ln45"> </a>
<a name="ln46">    // Verificar si está dentro del tablero</a>
<a name="ln47">    if (new_x &gt;= 0 &amp;&amp; new_x &lt; game-&gt;width &amp;&amp; new_y &gt;= 0 &amp;&amp;</a>
<a name="ln48">        new_y &lt; game-&gt;height) {</a>
<a name="ln49">      // Verificar si la celda no está ocupada por otro jugador</a>
<a name="ln50">      bool occupied = false;</a>
<a name="ln51">      for (unsigned int p = 0; p &lt; game-&gt;player_count; p++) {</a>
<a name="ln52">        if (p != player_id &amp;&amp; game-&gt;players[p].x == new_x &amp;&amp;</a>
<a name="ln53">            game-&gt;players[p].y == new_y) {</a>
<a name="ln54">          occupied = true;</a>
<a name="ln55">          break;</a>
<a name="ln56">        }</a>
<a name="ln57">      }</a>
<a name="ln58">      if (!occupied) {</a>
<a name="ln59">        return false; // Tiene al menos un movimiento válido</a>
<a name="ln60">      }</a>
<a name="ln61">    }</a>
<a name="ln62">  }</a>
<a name="ln63">  return true; // No tiene movimientos válidos, está bloqueado</a>
<a name="ln64">}</a>
<a name="ln65"> </a>
<a name="ln66">// Función para dibujar el tablero limpio</a>
<a name="ln67">void print_board_ncurses(game_t *game) {</a>
<a name="ln68">  clear();</a>
<a name="ln69"> </a>
<a name="ln70">  // Título del juego</a>
<a name="ln71">  attron(COLOR_PAIR(COLOR_PAIR_TITLE) | A_BOLD);</a>
<a name="ln72">  int title_x = (COLS - 20) / 2;</a>
<a name="ln73">  mvprintw(1, title_x, &quot;ChompChamps Board&quot;);</a>
<a name="ln74">  attroff(COLOR_PAIR(COLOR_PAIR_TITLE) | A_BOLD);</a>
<a name="ln75"> </a>
<a name="ln76">  // Calcular posición del tablero (centrado)</a>
<a name="ln77">  int board_start_y = 3;</a>
<a name="ln78">  int board_start_x = (COLS - (game-&gt;width * 4 + 1)) / 2;</a>
<a name="ln79"> </a>
<a name="ln80">  // Dibujar borde superior del tablero</a>
<a name="ln81">  attron(COLOR_PAIR(COLOR_PAIR_BOARD));</a>
<a name="ln82">  mvaddch(board_start_y, board_start_x, ACS_ULCORNER);</a>
<a name="ln83">  for (int j = 0; j &lt; game-&gt;width; j++) {</a>
<a name="ln84">    mvaddch(board_start_y, board_start_x + 1 + j * 4, ACS_HLINE);</a>
<a name="ln85">    mvaddch(board_start_y, board_start_x + 2 + j * 4, ACS_HLINE);</a>
<a name="ln86">    mvaddch(board_start_y, board_start_x + 3 + j * 4, ACS_HLINE);</a>
<a name="ln87">    if (j &lt; game-&gt;width - 1) {</a>
<a name="ln88">      mvaddch(board_start_y, board_start_x + 4 + j * 4, ACS_TTEE);</a>
<a name="ln89">    }</a>
<a name="ln90">  }</a>
<a name="ln91">  mvaddch(board_start_y, board_start_x + game-&gt;width * 4, ACS_URCORNER);</a>
<a name="ln92"> </a>
<a name="ln93">  // Dibujar filas del tablero</a>
<a name="ln94">  for (int i = 0; i &lt; game-&gt;height; i++) {</a>
<a name="ln95">    int row_y = board_start_y + 1 + i * 2;</a>
<a name="ln96"> </a>
<a name="ln97">    // Línea con contenido</a>
<a name="ln98">    mvaddch(row_y, board_start_x, ACS_VLINE);</a>
<a name="ln99">    for (int j = 0; j &lt; game-&gt;width; j++) {</a>
<a name="ln100">      int cell_value = game-&gt;board[i * game-&gt;width + j];</a>
<a name="ln101">      int cell_x = board_start_x + 1 + j * 4;</a>
<a name="ln102"> </a>
<a name="ln103">      // Verificar si hay un jugador en esta celda</a>
<a name="ln104">      bool has_player = false;</a>
<a name="ln105">      int player_id = -1;</a>
<a name="ln106">      for (unsigned int p = 0; p &lt; game-&gt;player_count; p++) {</a>
<a name="ln107">        if (game-&gt;players[p].x == j &amp;&amp; game-&gt;players[p].y == i) {</a>
<a name="ln108">          has_player = true;</a>
<a name="ln109">          player_id = p;</a>
<a name="ln110">          break;</a>
<a name="ln111">        }</a>
<a name="ln112">      }</a>
<a name="ln113"> </a>
<a name="ln114">      if (has_player) {</a>
<a name="ln115">        // Mostrar jugador</a>
<a name="ln116">        attron(COLOR_PAIR(get_player_color(player_id)) | A_BOLD);</a>
<a name="ln117">        mvprintw(row_y, cell_x, &quot;P%d &quot;, player_id + 1);</a>
<a name="ln118">        attroff(COLOR_PAIR(get_player_color(player_id)) | A_BOLD);</a>
<a name="ln119">      } else {</a>
<a name="ln120">        // Mostrar número de la celda</a>
<a name="ln121">        attron(COLOR_PAIR(COLOR_PAIR_NUMBER));</a>
<a name="ln122">        mvprintw(row_y, cell_x, &quot;%2d &quot;, cell_value);</a>
<a name="ln123">        attroff(COLOR_PAIR(COLOR_PAIR_NUMBER));</a>
<a name="ln124">      }</a>
<a name="ln125"> </a>
<a name="ln126">      mvaddch(row_y, board_start_x + 4 + j * 4, ACS_VLINE);</a>
<a name="ln127">    }</a>
<a name="ln128"> </a>
<a name="ln129">    // Línea separadora (excepto la última fila)</a>
<a name="ln130">    if (i &lt; game-&gt;height - 1) {</a>
<a name="ln131">      int sep_y = row_y + 1;</a>
<a name="ln132">      mvaddch(sep_y, board_start_x, ACS_LTEE);</a>
<a name="ln133">      for (int j = 0; j &lt; game-&gt;width; j++) {</a>
<a name="ln134">        mvaddch(sep_y, board_start_x + 1 + j * 4, ACS_HLINE);</a>
<a name="ln135">        mvaddch(sep_y, board_start_x + 2 + j * 4, ACS_HLINE);</a>
<a name="ln136">        mvaddch(sep_y, board_start_x + 3 + j * 4, ACS_HLINE);</a>
<a name="ln137">        if (j &lt; game-&gt;width - 1) {</a>
<a name="ln138">          mvaddch(sep_y, board_start_x + 4 + j * 4, ACS_PLUS);</a>
<a name="ln139">        }</a>
<a name="ln140">      }</a>
<a name="ln141">      mvaddch(sep_y, board_start_x + game-&gt;width * 4, ACS_RTEE);</a>
<a name="ln142">    }</a>
<a name="ln143">  }</a>
<a name="ln144"> </a>
<a name="ln145">  // Borde inferior del tablero</a>
<a name="ln146">  int bottom_y = board_start_y + 1 + (game-&gt;height - 1) * 2 + 1;</a>
<a name="ln147">  mvaddch(bottom_y, board_start_x, ACS_LLCORNER);</a>
<a name="ln148">  for (int j = 0; j &lt; game-&gt;width; j++) {</a>
<a name="ln149">    mvaddch(bottom_y, board_start_x + 1 + j * 4, ACS_HLINE);</a>
<a name="ln150">    mvaddch(bottom_y, board_start_x + 2 + j * 4, ACS_HLINE);</a>
<a name="ln151">    mvaddch(bottom_y, board_start_x + 3 + j * 4, ACS_HLINE);</a>
<a name="ln152">    if (j &lt; game-&gt;width - 1) {</a>
<a name="ln153">      mvaddch(bottom_y, board_start_x + 4 + j * 4, ACS_BTEE);</a>
<a name="ln154">    }</a>
<a name="ln155">  }</a>
<a name="ln156">  mvaddch(bottom_y, board_start_x + game-&gt;width * 4, ACS_LRCORNER);</a>
<a name="ln157">  attroff(COLOR_PAIR(COLOR_PAIR_BOARD));</a>
<a name="ln158"> </a>
<a name="ln159">  // Scoreboard (abajo a la izquierda)</a>
<a name="ln160">  int score_y = bottom_y + 3;</a>
<a name="ln161">  attron(COLOR_PAIR(COLOR_PAIR_INFO) | A_BOLD);</a>
<a name="ln162">  mvprintw(score_y, 2, &quot;Scoreboard&quot;);</a>
<a name="ln163">  attroff(COLOR_PAIR(COLOR_PAIR_INFO) | A_BOLD);</a>
<a name="ln164"> </a>
<a name="ln165">  for (unsigned int i = 0; i &lt; game-&gt;player_count; i++) {</a>
<a name="ln166">    attron(COLOR_PAIR(get_player_color(i)));</a>
<a name="ln167">    mvprintw(score_y + i + 1, 2, &quot;P%d&quot;, (int)(i + 1));</a>
<a name="ln168">    attroff(COLOR_PAIR(get_player_color(i)));</a>
<a name="ln169"> </a>
<a name="ln170">    attron(COLOR_PAIR(COLOR_PAIR_INFO));</a>
<a name="ln171">    mvprintw(score_y + i + 1, 6, &quot;player%d&quot;, (int)(i + 1));</a>
<a name="ln172"> </a>
<a name="ln173">    // Verificar si está bloqueado usando la función</a>
<a name="ln174">    bool blocked = is_player_blocked(game, i);</a>
<a name="ln175">    mvprintw(score_y + i + 1, 20, &quot;Score: %3d  Moves: %2d/%2d [%s]&quot;,</a>
<a name="ln176">             (int)game-&gt;players[i].score, (int)game-&gt;players[i].valid_requests,</a>
<a name="ln177">             (int)game-&gt;players[i].invalid_requests,</a>
<a name="ln178">             blocked ? &quot;BLOCKED&quot; : &quot;ACTIVE&quot;);</a>
<a name="ln179">    attroff(COLOR_PAIR(COLOR_PAIR_INFO));</a>
<a name="ln180">  }</a>
<a name="ln181"> </a>
<a name="ln182">  // Leyenda (abajo a la derecha) - Solo jugadores</a>
<a name="ln183">  int legend_x = COLS - 20;</a>
<a name="ln184">  attron(COLOR_PAIR(COLOR_PAIR_INFO) | A_BOLD);</a>
<a name="ln185">  mvprintw(score_y, legend_x, &quot;Legend&quot;);</a>
<a name="ln186">  attroff(COLOR_PAIR(COLOR_PAIR_INFO) | A_BOLD);</a>
<a name="ln187"> </a>
<a name="ln188">  for (unsigned int i = 0; i &lt; game-&gt;player_count; i++) {</a>
<a name="ln189">    attron(COLOR_PAIR(get_player_color(i)));</a>
<a name="ln190">    mvprintw(score_y + 1 + i, legend_x, &quot;P%d - Player %d&quot;, (int)(i + 1),</a>
<a name="ln191">             (int)(i + 1));</a>
<a name="ln192">    attroff(COLOR_PAIR(get_player_color(i)));</a>
<a name="ln193">  }</a>
<a name="ln194"> </a>
<a name="ln195">  refresh();</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198">int main(int argc, char *argv[]) {</a>
<a name="ln199"> </a>
<a name="ln200">  if (argc != 3) {</a>
<a name="ln201">    printf(&quot;Uso: %s &lt;width&gt; &lt;height&gt;\n&quot;, argv[0]);</a>
<a name="ln202">    return 1;</a>
<a name="ln203">  }</a>
<a name="ln204">  </a>
<a name="ln205">  game_t *game = open_game_memory(sizeof(game_t) + (atoi(argv[1]) * atoi(argv[2]) * sizeof(int)));</a>
<a name="ln206">  sync_t *sync = open_sync_memory(sizeof(sync_t));</a>
<a name="ln207"> </a>
<a name="ln208">  // Inicializar ncurses</a>
<a name="ln209">  setenv(&quot;TERM&quot;, &quot;xterm-256color&quot;, 1);</a>
<a name="ln210">  initscr();</a>
<a name="ln211">  start_color();</a>
<a name="ln212">  cbreak();</a>
<a name="ln213">  noecho();</a>
<a name="ln214">  keypad(stdscr, TRUE);</a>
<a name="ln215">  curs_set(0);</a>
<a name="ln216"> </a>
<a name="ln217">  if (!has_colors()) {</a>
<a name="ln218">    endwin();</a>
<a name="ln219">    printf(&quot;Tu terminal no soporta colores.\n&quot;);</a>
<a name="ln220">    exit(1);</a>
<a name="ln221">  }</a>
<a name="ln222"> </a>
<a name="ln223">  // Definir pares de colores</a>
<a name="ln224">  init_pair(COLOR_PAIR_BOARD, COLOR_WHITE, COLOR_BLACK);</a>
<a name="ln225">  init_pair(COLOR_PAIR_NUMBER, COLOR_GREEN, COLOR_BLACK);</a>
<a name="ln226">  init_pair(COLOR_PAIR_PLAYER1, COLOR_BLACK, COLOR_RED);</a>
<a name="ln227">  init_pair(COLOR_PAIR_PLAYER2, COLOR_BLACK, COLOR_YELLOW);</a>
<a name="ln228">  init_pair(COLOR_PAIR_PLAYER3, COLOR_BLACK, COLOR_MAGENTA);</a>
<a name="ln229">  init_pair(COLOR_PAIR_TITLE, COLOR_WHITE, COLOR_BLUE);</a>
<a name="ln230">  init_pair(COLOR_PAIR_INFO, COLOR_CYAN, COLOR_BLACK);</a>
<a name="ln231"> </a>
<a name="ln232">  nodelay(stdscr, TRUE);</a>
<a name="ln233"> </a>
<a name="ln234">  while (true) {</a>
<a name="ln235">    if (sem_wait(&amp;sync-&gt;master_to_view) == -1) {</a>
<a name="ln236">      if (errno == EINTR)</a>
<a name="ln237">        continue;</a>
<a name="ln238">      perror(&quot;sem_wait master_to_view&quot;);</a>
<a name="ln239">      break;</a>
<a name="ln240">    }</a>
<a name="ln241"> </a>
<a name="ln242">    print_board_ncurses(game);</a>
<a name="ln243"> </a>
<a name="ln244">    if (sem_post(&amp;sync-&gt;view_to_master) == -1) {</a>
<a name="ln245">      perror(&quot;sem_post view_to_master&quot;);</a>
<a name="ln246">      break;</a>
<a name="ln247">    }</a>
<a name="ln248"> </a>
<a name="ln249">    if (game-&gt;finished) {</a>
<a name="ln250">      mvprintw(LINES - 2, 0,</a>
<a name="ln251">               &quot;¡Juego terminado! Presiona cualquier tecla para salir...&quot;);</a>
<a name="ln252">      refresh();</a>
<a name="ln253">      nodelay(stdscr, FALSE);</a>
<a name="ln254">      getch();</a>
<a name="ln255">      break;</a>
<a name="ln256">    }</a>
<a name="ln257"> </a>
<a name="ln258">    napms(50);</a>
<a name="ln259">  }</a>
<a name="ln260"> </a>
<a name="ln261">  endwin();</a>
<a name="ln262">  return 0;</a>
<a name="ln263">}</a>
</code></pre>
<div class="balloon" rel="224"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v525/" target="_blank">V525</a> The code contains the collection of similar blocks. Check items '7', '2', '0', '0', '0', '7', '6' in lines 224, 225, 226, 227, 228, 229, 230.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>