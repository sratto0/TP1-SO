<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>master_lib.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is a personal academic project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++, C#, and Java:</a>
<a name="ln3">// https://pvs-studio.com</a>
<a name="ln4"> </a>
<a name="ln5">#include &quot;master_lib.h&quot;</a>
<a name="ln6"> </a>
<a name="ln7">void argument_amount_check(int argc) {</a>
<a name="ln8">  if (argc &lt; 3) {</a>
<a name="ln9">    err_msg(&quot;Incorrect number of arguments\n&quot;);</a>
<a name="ln10">  }</a>
<a name="ln11">}</a>
<a name="ln12"> </a>
<a name="ln13">void get_arguments(int argc, char *argv[], unsigned short *width,</a>
<a name="ln14">                   unsigned short *height, unsigned int *delay,</a>
<a name="ln15">                   unsigned int *timeout, unsigned int *seed, char **view_path,</a>
<a name="ln16">                   char **players_paths, int *player_count) {</a>
<a name="ln17">  int opt;</a>
<a name="ln18"> </a>
<a name="ln19">  while ((opt = getopt(argc, argv, &quot;w:h:d:t:s:v:p:&quot;)) != -1) {</a>
<a name="ln20">    switch (opt) {</a>
<a name="ln21">    case 'w':</a>
<a name="ln22">      *width = atoi(optarg);</a>
<a name="ln23">      break;</a>
<a name="ln24">    case 'h':</a>
<a name="ln25">      *height = atoi(optarg);</a>
<a name="ln26">      break;</a>
<a name="ln27">    case 'd':</a>
<a name="ln28">      *delay = atoi(optarg);</a>
<a name="ln29">      break;</a>
<a name="ln30">    case 't':</a>
<a name="ln31">      *timeout = atoi(optarg);</a>
<a name="ln32">      break;</a>
<a name="ln33">    case 's':</a>
<a name="ln34">      *seed = atoi(optarg);</a>
<a name="ln35">      break;</a>
<a name="ln36">    case 'v':</a>
<a name="ln37">      *view_path = optarg;</a>
<a name="ln38">      break;</a>
<a name="ln39">    case 'p':</a>
<a name="ln40">      if (*player_count &lt; 9) {</a>
<a name="ln41">        players_paths[(*player_count)++] = optarg;</a>
<a name="ln42">      }</a>
<a name="ln43">      while (optind &lt; argc &amp;&amp; argv[optind][0] != '-') {</a>
<a name="ln44">        players_paths[(*player_count)++] = argv[optind++];</a>
<a name="ln45">      }</a>
<a name="ln46">      break;</a>
<a name="ln47">    default:</a>
<a name="ln48">      fprintf(stderr, &quot;Using: %s [-w width] [-h height] [-v view]\n&quot;, argv[0]);</a>
<a name="ln49">      exit(EXIT_FAILURE);</a>
<a name="ln50">      break;</a>
<a name="ln51">    }</a>
<a name="ln52">  }</a>
<a name="ln53">}</a>
<a name="ln54"> </a>
<a name="ln55">void check_player_count(int count) {</a>
<a name="ln56">  if (count &lt; 1 || count &gt; 9) {</a>
<a name="ln57">    err_msg(&quot;Invalid number of players&quot;);</a>
<a name="ln58">  }</a>
<a name="ln59">}</a>
<a name="ln60"> </a>
<a name="ln61">void init_sync(sync_t *sync) {</a>
<a name="ln62">  init_semaphore(&amp;sync-&gt;have_to_print, 0);</a>
<a name="ln63">  init_semaphore(&amp;sync-&gt;finished_printing, 0);</a>
<a name="ln64">  init_semaphore(&amp;sync-&gt;writer_mutex, 1);</a>
<a name="ln65">  init_semaphore(&amp;sync-&gt;state_mutex, 1);</a>
<a name="ln66">  init_semaphore(&amp;sync-&gt;readers_count_mutex, 1);</a>
<a name="ln67">  for (int i = 0; i &lt; MAX_PLAYERS; i++) {</a>
<a name="ln68">    init_semaphore(&amp;sync-&gt;players_ready[i], 1);</a>
<a name="ln69">  }</a>
<a name="ln70">  sync-&gt;readers_count = 0;</a>
<a name="ln71">}</a>
<a name="ln72"> </a>
<a name="ln73">void init_semaphore(sem_t *sem, int value) {</a>
<a name="ln74">  if (sem_init(sem, 1, value) == -1)</a>
<a name="ln75">    err_exit(&quot;sem_init&quot;);</a>
<a name="ln76">}</a>
<a name="ln77"> </a>
<a name="ln78">void init_game(game_t *game, unsigned short width, unsigned short height,</a>
<a name="ln79">               unsigned int player_count) {</a>
<a name="ln80">  game-&gt;width = width;</a>
<a name="ln81">  game-&gt;height = height;</a>
<a name="ln82">  game-&gt;player_count = player_count;</a>
<a name="ln83">  game-&gt;finished = false;</a>
<a name="ln84">}</a>
<a name="ln85"> </a>
<a name="ln86">void fill_board(game_t *game) {</a>
<a name="ln87">  srand(time(NULL));</a>
<a name="ln88">  for (int i = 0; i &lt; (game-&gt;width * game-&gt;height); i++) {</a>
<a name="ln89">    game-&gt;board[i] = (rand() % 9) + 1;</a>
<a name="ln90">  }</a>
<a name="ln91">}</a>
<a name="ln92"> </a>
<a name="ln93">void print_configuration(unsigned short width, unsigned short height,</a>
<a name="ln94">                         unsigned int delay, unsigned int timeout,</a>
<a name="ln95">                         unsigned int seed, char *view_path,</a>
<a name="ln96">                         char **players_paths, int player_count) {</a>
<a name="ln97">  printf(&quot;width = %d\nheight = %d\ndelay = %dms\ntimeout = %ds\nseed=%d\nview &quot;</a>
<a name="ln98">         &quot;= %s\nplayers:\n&quot;,</a>
<a name="ln99">         width, height, delay, timeout, seed,</a>
<a name="ln100">         view_path != NULL ? view_path : &quot; - &quot;);</a>
<a name="ln101"> </a>
<a name="ln102">  for (int i = 0; i &lt; player_count; i++) {</a>
<a name="ln103">    printf(&quot;  %s\n&quot;, players_paths[i]);</a>
<a name="ln104">  }</a>
<a name="ln105">}</a>
<a name="ln106"> </a>
<a name="ln107">void create_view_process(char *path, char *width, char *height, pid_t *pid) {</a>
<a name="ln108">  if (path != NULL) {</a>
<a name="ln109">    if (access(path, X_OK) == 0) {</a>
<a name="ln110">      *pid = fork();</a>
<a name="ln111">      if (*pid == -1) {</a>
<a name="ln112">        err_exit(&quot;Fork error&quot;);</a>
<a name="ln113">      } else if (*pid == 0) {</a>
<a name="ln114">        char *argv[] = {path, width, height, NULL};</a>
<a name="ln115">        if (execve(path, argv, NULL) == -1) {</a>
<a name="ln116">          err_exit(&quot;Execve error&quot;);</a>
<a name="ln117">        }</a>
<a name="ln118">      }</a>
<a name="ln119">    } else {</a>
<a name="ln120">      printf(&quot;View path is not executable or does not exist\n&quot;);</a>
<a name="ln121">      path = NULL;</a>
<a name="ln122">    }</a>
<a name="ln123">  }</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126">void init_players_data_and_pipes(game_t *game, int players_pipes[][2],</a>
<a name="ln127">                                 int player_count, int *max_fd) {</a>
<a name="ln128">  *max_fd = 0;</a>
<a name="ln129">  for (int i = 0; i &lt; player_count; i++) {</a>
<a name="ln130">    char name[] = {'P', 'l', 'a', 'y', 'e', 'r', '_', '0' + i, '\0'};</a>
<a name="ln131">    strcpy(game-&gt;players[i].name, name);</a>
<a name="ln132">    game-&gt;players[i].score = 0;</a>
<a name="ln133">    game-&gt;players[i].valid_requests = 0;</a>
<a name="ln134">    game-&gt;players[i].invalid_requests = 0;</a>
<a name="ln135">    game-&gt;players[i].blocked = false;</a>
<a name="ln136"> </a>
<a name="ln137">    if (pipe(players_pipes[i]) == -1) {</a>
<a name="ln138">      err_exit(&quot;pipe&quot;);</a>
<a name="ln139">    }</a>
<a name="ln140">    if (players_pipes[i][0] &gt; *max_fd) {</a>
<a name="ln141">      *max_fd = players_pipes[i][0];</a>
<a name="ln142">    }</a>
<a name="ln143">  }</a>
<a name="ln144">  player_pos(game);</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">void player_pos(game_t *game) {</a>
<a name="ln148">  unsigned short a = (game-&gt;height / 2) * 0.7; </a>
<a name="ln149">  unsigned short b = (game-&gt;width / 2) * 0.7;  </a>
<a name="ln150"> </a>
<a name="ln151">  if (game-&gt;player_count == 1) {</a>
<a name="ln152">    game-&gt;players[0].x = game-&gt;width / 2;</a>
<a name="ln153">    game-&gt;players[0].y = game-&gt;height / 2;</a>
<a name="ln154">    game-&gt;board[game-&gt;players[0].y * game-&gt;width + game-&gt;players[0].x] = 0;</a>
<a name="ln155">  } else {</a>
<a name="ln156">    for (unsigned int i = 0; i &lt; game-&gt;player_count; i++) {</a>
<a name="ln157">      double theta = (2.0 * M_PI * i) / game-&gt;player_count;</a>
<a name="ln158"> </a>
<a name="ln159">      game-&gt;players[i].x = (unsigned short)((game-&gt;width / 2) + b * cos(theta));</a>
<a name="ln160">      game-&gt;players[i].y =</a>
<a name="ln161">          (unsigned short)((game-&gt;height / 2) + a * sin(theta));</a>
<a name="ln162"> </a>
<a name="ln163">      if (game-&gt;players[i].x &lt; game-&gt;width &amp;&amp;</a>
<a name="ln164">          game-&gt;players[i].y &lt; game-&gt;height) {</a>
<a name="ln165">        game-&gt;board[game-&gt;players[i].y * game-&gt;width + game-&gt;players[i].x] = -i;</a>
<a name="ln166">      }</a>
<a name="ln167">    }</a>
<a name="ln168">  }</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">void create_players_processes(char **paths, int fds[][2], char *width,</a>
<a name="ln172">                              char *height, int player_count, game_t *game) {</a>
<a name="ln173">  for (int i = 0; i &lt; player_count; i++) {</a>
<a name="ln174">    if (access(paths[i], X_OK) == 0) {</a>
<a name="ln175">      pid_t pid = fork();</a>
<a name="ln176">      if (pid == -1) {</a>
<a name="ln177">        err_exit(&quot;Fork error&quot;);</a>
<a name="ln178">      } else if (pid == 0) {</a>
<a name="ln179">        close_not_needed_fds(fds, player_count, i);</a>
<a name="ln180">        if (dup2(fds[i][1], STDOUT_FILENO) == -1) {</a>
<a name="ln181">          err_exit(&quot;Dup2 error&quot;);</a>
<a name="ln182">        }</a>
<a name="ln183">        safe_close(fds[i][1]);</a>
<a name="ln184">        char *argv[] = {paths[i], width, height, NULL};</a>
<a name="ln185">        if (execve(argv[0], argv, NULL) == -1) {</a>
<a name="ln186">          err_exit(&quot;Execve error&quot;);</a>
<a name="ln187">        }</a>
<a name="ln188">      } else {</a>
<a name="ln189">        game-&gt;players[i].process_id = pid;</a>
<a name="ln190">      }</a>
<a name="ln191">    } else {</a>
<a name="ln192">      game-&gt;players[i].process_id = 0;</a>
<a name="ln193">    }</a>
<a name="ln194">  }</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">void close_not_needed_fds(int players_fds[][2], int player_count,</a>
<a name="ln198">                          int current_player) {</a>
<a name="ln199">  for (int i = 0; i &lt; player_count; i++) {</a>
<a name="ln200">    if (i == current_player) {</a>
<a name="ln201">      safe_close(players_fds[current_player][0]);</a>
<a name="ln202">    } else {</a>
<a name="ln203">      safe_close(players_fds[i][0]);</a>
<a name="ln204">      safe_close(players_fds[i][1]);</a>
<a name="ln205">    }</a>
<a name="ln206">  }</a>
<a name="ln207">}</a>
<a name="ln208"> </a>
<a name="ln209">void safe_close(int fd) {</a>
<a name="ln210">  if (close(fd) == -1) {</a>
<a name="ln211">    err_exit(&quot;Close pipe error\n&quot;);</a>
<a name="ln212">  }</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215">void setup_fds_for_select(game_t *game, int players_fds[][2], int player_count,</a>
<a name="ln216">                          fd_set *active_fds) {</a>
<a name="ln217">  FD_ZERO(active_fds);</a>
<a name="ln218"> </a>
<a name="ln219">  for (int i = 0; i &lt; player_count; i++) {</a>
<a name="ln220">    if (game-&gt;players[i].process_id == 0) {</a>
<a name="ln221">      safe_close(players_fds[i][0]);</a>
<a name="ln222">    } else {</a>
<a name="ln223">      FD_SET(players_fds[i][0], active_fds);</a>
<a name="ln224">    }</a>
<a name="ln225">    safe_close(players_fds[i][1]);</a>
<a name="ln226">  }</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229">int game_ended(game_t *game) {</a>
<a name="ln230">  int ended = 1;</a>
<a name="ln231">  for (unsigned int i = 0; i &lt; game-&gt;player_count &amp;&amp; ended; i++) {</a>
<a name="ln232">    if (!game-&gt;players[i].blocked) {</a>
<a name="ln233">      ended = 0;</a>
<a name="ln234">    }</a>
<a name="ln235">  }</a>
<a name="ln236">  return ended;</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">void game_over(game_t *game, sync_t *sync) {</a>
<a name="ln240">  sem_wait_check(&amp;sync-&gt;writer_mutex);</a>
<a name="ln241">  sem_wait_check(&amp;sync-&gt;state_mutex);</a>
<a name="ln242">  game-&gt;finished = true;</a>
<a name="ln243">  sem_post_check(&amp;sync-&gt;writer_mutex);</a>
<a name="ln244">  sem_post_check(&amp;sync-&gt;state_mutex);</a>
<a name="ln245">}</a>
<a name="ln246"> </a>
<a name="ln247">bool timeout_check(time_t last_move_time, unsigned int timeout, game_t *game,</a>
<a name="ln248">                   sync_t *sync) {</a>
<a name="ln249">  if (time(NULL) - last_move_time &gt; timeout) {</a>
<a name="ln250">    printf(&quot;Reached global timeout\n&quot;);</a>
<a name="ln251">    game_over(game, sync);</a>
<a name="ln252">    return true;</a>
<a name="ln253">  }</a>
<a name="ln254">  return false;</a>
<a name="ln255">}</a>
<a name="ln256"> </a>
<a name="ln257">void process_players(game_t *game, sync_t *sync, int player_count,</a>
<a name="ln258">                     int players_fds[][2], fd_set read_fds, int *last_served,</a>
<a name="ln259">                     time_t *last_move_time, unsigned int delay) {</a>
<a name="ln260">  for (int j = 0; j &lt; player_count; j++) {</a>
<a name="ln261">    int i = (*last_served + j) % player_count;</a>
<a name="ln262"> </a>
<a name="ln263">    if (FD_ISSET(players_fds[i][0], &amp;read_fds)) {</a>
<a name="ln264">      unsigned char dir;</a>
<a name="ln265">      int result = receive_move(players_fds[i][0], &amp;dir);</a>
<a name="ln266"> </a>
<a name="ln267">      if (result == -1) {</a>
<a name="ln268">        game-&gt;players[i].blocked = true;</a>
<a name="ln269">      } else {</a>
<a name="ln270">        bool moved = execute_move(game, sync, i, dir);</a>
<a name="ln271">        if (moved) {</a>
<a name="ln272">          *last_move_time = time(NULL);</a>
<a name="ln273"> </a>
<a name="ln274">          sync_with_view(sync, delay);</a>
<a name="ln275"> </a>
<a name="ln276">          if (!any_player_can_move(game)) {</a>
<a name="ln277">            printf(&quot;The game has ended: no player can move\n&quot;);</a>
<a name="ln278">            game_over(game, sync);</a>
<a name="ln279">            sync_with_view(sync, delay);</a>
<a name="ln280">            break;</a>
<a name="ln281">          }</a>
<a name="ln282">        }</a>
<a name="ln283">        if(!game-&gt;players[i].blocked){</a>
<a name="ln284">          sem_post_check(&amp;sync-&gt;players_ready[i]); </a>
<a name="ln285">        }</a>
<a name="ln286">      }</a>
<a name="ln287"> </a>
<a name="ln288">      *last_served = (i + 1) % player_count;</a>
<a name="ln289">      break;  </a>
<a name="ln290">    }</a>
<a name="ln291">  }</a>
<a name="ln292">}</a>
<a name="ln293"> </a>
<a name="ln294">int receive_move(int fd, unsigned char *dir) {</a>
<a name="ln295">  ssize_t n = read(fd, dir, 1);</a>
<a name="ln296">  if (n == 0) {</a>
<a name="ln297">    // EOF</a>
<a name="ln298">    return -1;</a>
<a name="ln299">  } else if (n &lt; 0) {</a>
<a name="ln300">    perror(&quot;read&quot;);</a>
<a name="ln301">    return -1;</a>
<a name="ln302">  }</a>
<a name="ln303"> </a>
<a name="ln304">  return 1;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">bool execute_move(game_t *game, sync_t *sync, int turno, unsigned char dir) {</a>
<a name="ln308">  sem_wait_check(&amp;sync-&gt;writer_mutex);</a>
<a name="ln309">  sem_wait_check(&amp;sync-&gt;state_mutex);</a>
<a name="ln310">  sem_post_check(&amp;sync-&gt;writer_mutex);</a>
<a name="ln311"> </a>
<a name="ln312">  bool valid = false;</a>
<a name="ln313"> </a>
<a name="ln314">  if (dir &gt; 7) {</a>
<a name="ln315">    game-&gt;players[turno].invalid_requests++;</a>
<a name="ln316">  } else {</a>
<a name="ln317">    int dx = directions[dir][0];</a>
<a name="ln318">    int dy = directions[dir][1];</a>
<a name="ln319">    int new_x = game-&gt;players[turno].x + dx;</a>
<a name="ln320">    int new_y = game-&gt;players[turno].y + dy;</a>
<a name="ln321"> </a>
<a name="ln322">    if (!is_valid_move(new_x, new_y, game)) {</a>
<a name="ln323">      game-&gt;players[turno].invalid_requests++;</a>
<a name="ln324">    } else {</a>
<a name="ln325">      int cell_value = game-&gt;board[new_y * game-&gt;width + new_x];</a>
<a name="ln326">      game-&gt;players[turno].score += cell_value;</a>
<a name="ln327"> </a>
<a name="ln328">      game-&gt;board[new_y * game-&gt;width + new_x] = -turno;</a>
<a name="ln329">      game-&gt;players[turno].x = new_x;</a>
<a name="ln330">      game-&gt;players[turno].y = new_y;</a>
<a name="ln331">      game-&gt;players[turno].valid_requests++;</a>
<a name="ln332"> </a>
<a name="ln333">      valid = true;</a>
<a name="ln334">    }</a>
<a name="ln335">  }</a>
<a name="ln336"> </a>
<a name="ln337">  for (unsigned int i = 0; i &lt; game-&gt;player_count; i++) {</a>
<a name="ln338">    if (!game-&gt;players[i].blocked &amp;&amp; !has_valid_moves(game, &amp;game-&gt;players[i])) {</a>
<a name="ln339">      game-&gt;players[i].blocked = true;</a>
<a name="ln340">    }</a>
<a name="ln341">  }</a>
<a name="ln342"> </a>
<a name="ln343">  sem_post_check(&amp;sync-&gt;state_mutex);</a>
<a name="ln344"> </a>
<a name="ln345">  return valid;</a>
<a name="ln346">}</a>
<a name="ln347"> </a>
<a name="ln348">void sync_with_view(sync_t *sync, unsigned int delay) {</a>
<a name="ln349">  sem_post_check(&amp;sync-&gt;have_to_print);</a>
<a name="ln350">  sem_wait_check(&amp;sync-&gt;finished_printing);</a>
<a name="ln351">  usleep(delay * 1000);</a>
<a name="ln352">}</a>
<a name="ln353"> </a>
<a name="ln354">bool any_player_can_move(game_t *game) {</a>
<a name="ln355">  for (unsigned int i = 0; i &lt; game-&gt;player_count; i++) {</a>
<a name="ln356">    if (game-&gt;players[i].blocked) {</a>
<a name="ln357">      continue;</a>
<a name="ln358">    }</a>
<a name="ln359"> </a>
<a name="ln360">    if (has_valid_moves(game, &amp;game-&gt;players[i])) {</a>
<a name="ln361">      return true;</a>
<a name="ln362">    }</a>
<a name="ln363">  }</a>
<a name="ln364"> </a>
<a name="ln365">  return false;</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368">bool is_valid_move(int x, int y, game_t *game) {</a>
<a name="ln369">  return (x &gt;= 0 &amp;&amp; x &lt; game-&gt;width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; game-&gt;height &amp;&amp;</a>
<a name="ln370">          game-&gt;board[y * game-&gt;width + x] &gt;= 1 &amp;&amp;</a>
<a name="ln371">          game-&gt;board[y * game-&gt;width + x] &lt;= 9);</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374">bool has_valid_moves(game_t *game, player_t *player) {</a>
<a name="ln375">  for (int dir = 0; dir &lt; 8; dir++) {</a>
<a name="ln376">    if (is_valid_move(player-&gt;x + directions[dir][0],</a>
<a name="ln377">                      player-&gt;y + directions[dir][1], game)) {</a>
<a name="ln378">      return true;</a>
<a name="ln379">    }</a>
<a name="ln380">  }</a>
<a name="ln381">  return false;</a>
<a name="ln382">}</a>
<a name="ln383"> </a>
<a name="ln384">void signal_all_players_ready(game_t *game, sync_t *sync, int player_count) {</a>
<a name="ln385">  for (int i = 0; i &lt; player_count; i++) {</a>
<a name="ln386">    if (game-&gt;players[i].process_id != 0) {</a>
<a name="ln387">      sem_post_check(&amp;sync-&gt;players_ready[i]);</a>
<a name="ln388">    }</a>
<a name="ln389">  }</a>
<a name="ln390">}</a>
<a name="ln391"> </a>
<a name="ln392">void wait_view(char *path, pid_t pid) {</a>
<a name="ln393">  int view_ret;</a>
<a name="ln394">  if (path != NULL) {</a>
<a name="ln395">    waitpid(pid, &amp;view_ret, 0);</a>
<a name="ln396">  }</a>
<a name="ln397">}</a>
<a name="ln398"> </a>
<a name="ln399">void close_and_wait_players(game_t *game, int players_fds[][2],</a>
<a name="ln400">                            int player_count) {</a>
<a name="ln401">  for (int i = 0; i &lt; player_count; i++) {</a>
<a name="ln402">    int status;</a>
<a name="ln403">    if (game-&gt;players[i].process_id != 0) {</a>
<a name="ln404">      safe_close(players_fds[i][0]);</a>
<a name="ln405">      waitpid(game-&gt;players[i].process_id, &amp;status, 0);</a>
<a name="ln406">    } else {</a>
<a name="ln407">      status = 256;</a>
<a name="ln408">    }</a>
<a name="ln409">  }</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412">void close_sems(sync_t *sync, unsigned int player_count) {</a>
<a name="ln413"> </a>
<a name="ln414">  for (unsigned int i = 0; i &lt; player_count; i++) {</a>
<a name="ln415">    sem_destroy_check(&amp;sync-&gt;players_ready[i]);</a>
<a name="ln416">  }</a>
<a name="ln417"> </a>
<a name="ln418">  sem_destroy_check(&amp;sync-&gt;have_to_print);</a>
<a name="ln419">  sem_destroy_check(&amp;sync-&gt;finished_printing);</a>
<a name="ln420">  sem_destroy_check(&amp;sync-&gt;writer_mutex);</a>
<a name="ln421">  sem_destroy_check(&amp;sync-&gt;state_mutex);</a>
<a name="ln422">  sem_destroy_check(&amp;sync-&gt;readers_count_mutex);</a>
<a name="ln423">}</a>
</code></pre>
<div class="balloon" rel="97"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'printf' function. The SIGNED integer type argument is expected.</p></div>
<div class="balloon" rel="97"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'printf' function. The SIGNED integer type argument is expected.</p></div>
<div class="balloon" rel="97"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v576/" target="_blank">V576</a> Incorrect format. Consider checking the sixth actual argument of the 'printf' function. The SIGNED integer type argument is expected.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>