<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>master.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is a personal academic project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++, C#, and Java:</a>
<a name="ln3">// https://pvs-studio.com</a>
<a name="ln4"> </a>
<a name="ln5">#include &quot;master_lib.h&quot;</a>
<a name="ln6"> </a>
<a name="ln7">int main(int argc, char *argv[]) {</a>
<a name="ln8"> </a>
<a name="ln9">  if (argc &lt; 3) {</a>
<a name="ln10">    err_exit(&quot;Incorrect number of arguments\n&quot;);</a>
<a name="ln11">  }</a>
<a name="ln12"> </a>
<a name="ln13">  int opt;</a>
<a name="ln14">  char *view_path = NULL;</a>
<a name="ln15">  unsigned int delay = 200;</a>
<a name="ln16">  unsigned int timeout = 10;</a>
<a name="ln17">  unsigned int seed = time(NULL);</a>
<a name="ln18">  char *players_paths[9] = {NULL};</a>
<a name="ln19">  int player_count = 0;</a>
<a name="ln20">  unsigned short width = 20;</a>
<a name="ln21">  unsigned short height = 10;</a>
<a name="ln22"> </a>
<a name="ln23">  while ((opt = getopt(argc, argv, &quot;w:h:d:t:s:v:p:&quot;)) != -1) {</a>
<a name="ln24">    switch (opt) {</a>
<a name="ln25">    case 'w':</a>
<a name="ln26">      width = atoi(optarg);</a>
<a name="ln27">      break;</a>
<a name="ln28">    case 'h':</a>
<a name="ln29">      height = atoi(optarg);</a>
<a name="ln30">      break;</a>
<a name="ln31">    case 'd':</a>
<a name="ln32">      delay = atoi(optarg);</a>
<a name="ln33">      break;</a>
<a name="ln34">    case 't':</a>
<a name="ln35">      timeout = atoi(optarg);</a>
<a name="ln36">      break;</a>
<a name="ln37">    case 's':</a>
<a name="ln38">      seed = atoi(optarg);</a>
<a name="ln39">      break;</a>
<a name="ln40">    case 'v':</a>
<a name="ln41">      view_path = optarg;</a>
<a name="ln42">      break;</a>
<a name="ln43">    case 'p':</a>
<a name="ln44">      // // primero con getopt habria que tener la cantidad de players</a>
<a name="ln45">      // players_paths[0] = &quot;./player&quot;; // hardcodeado para probarlo con 1 jugador</a>
<a name="ln46">      // break;</a>
<a name="ln47">      players_paths[player_count] = optarg;  // Usar optarg en lugar de hardcodear</a>
<a name="ln48">      player_count++;                       // Incrementar el contador</a>
<a name="ln49">      break;</a>
<a name="ln50">    default:</a>
<a name="ln51">      fprintf(stderr, &quot;Uso: %s [-w width] [-h height] [-v view]\n&quot;, argv[0]);</a>
<a name="ln52">      exit(EXIT_FAILURE);</a>
<a name="ln53">      break;</a>
<a name="ln54">    }</a>
<a name="ln55">  }</a>
<a name="ln56"> </a>
<a name="ln57">  if (player_count &lt; 1 || player_count &gt; 9) {</a>
<a name="ln58">    err_exit(&quot;Invalid number of players&quot;);</a>
<a name="ln59">  }</a>
<a name="ln60"> </a>
<a name="ln61">  game_t *game = create_game_memory(sizeof(game_t) + (width * height * sizeof(int)));</a>
<a name="ln62">  sync_t *sync = create_sync_memory(sizeof(sync_t));</a>
<a name="ln63"> </a>
<a name="ln64">  init_sync(sync);</a>
<a name="ln65">  init_game(game, width, height, player_count);</a>
<a name="ln66"> </a>
<a name="ln67">  fill_board(game);</a>
<a name="ln68"> </a>
<a name="ln69">  char argv_width[MAX_DIGITS] = {0};</a>
<a name="ln70">  char argv_height[MAX_DIGITS] = {0};</a>
<a name="ln71"> </a>
<a name="ln72">  sprintf(argv_width, &quot;%d&quot;, game-&gt;width);</a>
<a name="ln73">  sprintf(argv_height, &quot;%d&quot;, game-&gt;height);</a>
<a name="ln74"> </a>
<a name="ln75">  printf(&quot;width = %d\nheight = %d\ndelay = %dms\ntimeout = %ds\nseed=%d\nview &quot;</a>
<a name="ln76">         &quot;= %s\nplayers:\n&quot;,</a>
<a name="ln77">         width, height, delay, timeout, seed,</a>
<a name="ln78">         view_path != NULL ? view_path : &quot; - &quot;);</a>
<a name="ln79"> </a>
<a name="ln80">  for (int i = 0; i &lt; player_count; i++) {</a>
<a name="ln81">    printf(&quot;  %s\n&quot;, players_paths[i]);</a>
<a name="ln82">  }</a>
<a name="ln83"> </a>
<a name="ln84">  sleep(2);</a>
<a name="ln85"> </a>
<a name="ln86">  pid_t view_pid;</a>
<a name="ln87">  if (view_path != NULL) {</a>
<a name="ln88">    if (access(view_path, X_OK) == 0) {</a>
<a name="ln89">      view_pid = fork();</a>
<a name="ln90">      if (view_pid == -1) {</a>
<a name="ln91">        err_exit(&quot;Fork error&quot;);</a>
<a name="ln92">      } else if (view_pid == 0) {</a>
<a name="ln93">        char *view_argv[] = {view_path, argv_width, argv_height, NULL};</a>
<a name="ln94">        if (execve(view_path, view_argv, NULL) == -1) {</a>
<a name="ln95">          err_exit(&quot;Execve error&quot;);</a>
<a name="ln96">        }</a>
<a name="ln97">      }</a>
<a name="ln98">    } else {</a>
<a name="ln99">      printf(&quot;View path is not executable or does not exist\n&quot;);</a>
<a name="ln100">      view_path = NULL;</a>
<a name="ln101">    }</a>
<a name="ln102">  }</a>
<a name="ln103"> </a>
<a name="ln104">    int players_fds[player_count][2];</a>
<a name="ln105">    int max_fd;</a>
<a name="ln106">    </a>
<a name="ln107">    init_players(game, players_fds, player_count, &amp;max_fd);</a>
<a name="ln108">    </a>
<a name="ln109">    </a>
<a name="ln110">    for (int i = 0; i &lt; player_count; i++) {</a>
<a name="ln111">      if (access(players_paths[i], X_OK) == 0) {</a>
<a name="ln112">        pid_t player_pid = fork();</a>
<a name="ln113">        if (player_pid == -1) {</a>
<a name="ln114">          err_exit(&quot;Fork error&quot;);</a>
<a name="ln115">        } else if (player_pid == 0) {</a>
<a name="ln116">          close_not_needed_fds(players_fds, player_count, i);</a>
<a name="ln117">          if (dup2(players_fds[i][1], STDOUT_FILENO) == -1) {</a>
<a name="ln118">            err_exit(&quot;Dup2 error&quot;);</a>
<a name="ln119">          }</a>
<a name="ln120">          safe_close(players_fds[i][1]);</a>
<a name="ln121">          char *player_argv[] = {players_paths[i], argv_width, argv_height,</a>
<a name="ln122">                                 NULL};</a>
<a name="ln123">          if (execve(player_argv[0], player_argv, NULL) == -1) {</a>
<a name="ln124">            err_exit(&quot;Execve error&quot;);</a>
<a name="ln125">          }</a>
<a name="ln126">        } else {</a>
<a name="ln127">          game-&gt;players[i].process_id = player_pid;</a>
<a name="ln128">        }</a>
<a name="ln129">      } else {</a>
<a name="ln130">        game-&gt;players[i].process_id = 0;</a>
<a name="ln131">      }</a>
<a name="ln132">    }</a>
<a name="ln133"> </a>
<a name="ln134">    fd_set read_fds, active_fds;</a>
<a name="ln135">    FD_ZERO(&amp;active_fds);</a>
<a name="ln136"> </a>
<a name="ln137">    for (int i = 0; i &lt; player_count; i++) {</a>
<a name="ln138">      if (game-&gt;players[i].process_id == 0) {</a>
<a name="ln139">        safe_close(players_fds[i][0]);</a>
<a name="ln140">      } else {</a>
<a name="ln141">        FD_SET(players_fds[i][0], &amp;active_fds);</a>
<a name="ln142">      }</a>
<a name="ln143">      safe_close(players_fds[i][1]);</a>
<a name="ln144">    }</a>
<a name="ln145"> </a>
<a name="ln146">    time_t last_move_time = time(NULL);</a>
<a name="ln147">    </a>
<a name="ln148"> </a>
<a name="ln149">    int last_served = 0; // para implementar round-robin</a>
<a name="ln150"> </a>
<a name="ln151">    while (!game-&gt;finished) {</a>
<a name="ln152">        if (game_ended(game)) {</a>
<a name="ln153">            game_over(game, sync);</a>
<a name="ln154">            break;</a>
<a name="ln155">        }</a>
<a name="ln156"> </a>
<a name="ln157">        // Timeout global (tiempo sin movimientos válidos)</a>
<a name="ln158">        if (time(NULL) - last_move_time &gt; timeout) {</a>
<a name="ln159">            printf(&quot;Timeout global alcanzado\n&quot;);</a>
<a name="ln160">            game_over(game, sync);</a>
<a name="ln161">            break;</a>
<a name="ln162">        }</a>
<a name="ln163"> </a>
<a name="ln164">        read_fds = active_fds;</a>
<a name="ln165">        struct timeval tv = { .tv_sec = timeout, .tv_usec = 0 };</a>
<a name="ln166"> </a>
<a name="ln167">        int ready = select(max_fd + 1, &amp;read_fds, NULL, NULL, &amp;tv);</a>
<a name="ln168">        if (ready == -1) {</a>
<a name="ln169">            perror(&quot;select&quot;);</a>
<a name="ln170">            break;</a>
<a name="ln171">        } else if (ready == 0) {</a>
<a name="ln172">            printf(&quot;Timeout: nadie movió\n&quot;);</a>
<a name="ln173">            game_over(game, sync);</a>
<a name="ln174">            break;</a>
<a name="ln175">        }</a>
<a name="ln176"> </a>
<a name="ln177">        // Round-robin: recorrer jugadores a partir de last_served</a>
<a name="ln178">        for (int j = 0; j &lt; player_count; j++) {</a>
<a name="ln179">            int i = (last_served + j) % player_count;</a>
<a name="ln180"> </a>
<a name="ln181">            //otro fd_isset para que se ajuste a tener una receive y una execute</a>
<a name="ln182">            if (FD_ISSET(players_fds[i][0], &amp;read_fds)) {</a>
<a name="ln183"> </a>
<a name="ln184">              sem_wait_check(&amp;sync-&gt;players_ready[i]); </a>
<a name="ln185">              </a>
<a name="ln186">              unsigned char dir;</a>
<a name="ln187">              int result = receive_move(players_fds[i][0], &amp;dir);</a>
<a name="ln188"> </a>
<a name="ln189">              if (result == -1) {</a>
<a name="ln190">                  printf(&quot;Jugador %s terminó (EOF)\n&quot;, game-&gt;players[i].name);</a>
<a name="ln191">                  game-&gt;players[i].blocked = true;</a>
<a name="ln192">              } else {</a>
<a name="ln193">                  bool moved = execute_move(game, sync, i, dir);</a>
<a name="ln194">                  if (moved) {</a>
<a name="ln195">                      last_move_time = time(NULL);</a>
<a name="ln196"> </a>
<a name="ln197">                      // máster ↔ vista</a>
<a name="ln198">                      sem_post_check(&amp;sync-&gt;master_to_view);</a>
<a name="ln199">                      sem_wait_check(&amp;sync-&gt;view_to_master);</a>
<a name="ln200"> </a>
<a name="ln201">                      usleep(delay * 1000);</a>
<a name="ln202">                  }</a>
<a name="ln203">              }</a>
<a name="ln204">              sem_post(&amp;sync-&gt;players_ready[i]); // habilito jugador</a>
<a name="ln205">              last_served = (i + 1) % player_count;</a>
<a name="ln206">              break; // solo un movimiento por ronda</a>
<a name="ln207">          </a>
<a name="ln208"> </a>
<a name="ln209">            }</a>
<a name="ln210">        }</a>
<a name="ln211">    } //while</a>
<a name="ln212"> </a>
<a name="ln213">    int view_ret;</a>
<a name="ln214">    if (view_path != NULL) {</a>
<a name="ln215">      waitpid(view_pid, &amp;view_ret, 0);</a>
<a name="ln216">      printf(&quot;El view (%s) devolvio el valor %d\n&quot;, view_path, view_ret);</a>
<a name="ln217">    }</a>
<a name="ln218"> </a>
<a name="ln219">    for (int i = 0; i &lt; player_count; i++) {</a>
<a name="ln220">      int status;</a>
<a name="ln221">      if (game-&gt;players[i].process_id != 0) {</a>
<a name="ln222">        safe_close(players_fds[i][0]);</a>
<a name="ln223">        waitpid(game-&gt;players[i].process_id, &amp;status, 0);</a>
<a name="ln224">      }else {</a>
<a name="ln225">        status = 256;</a>
<a name="ln226">      }</a>
<a name="ln227">      printf(&quot;El player %s devolvio el valor %d\n&quot;, game-&gt;players[i].name, status);</a>
<a name="ln228">    }</a>
<a name="ln229"> </a>
<a name="ln230">    close_sems(sync, game-&gt;player_count);</a>
<a name="ln231">    close_memory(game, sizeof(game_t) + (width * height * sizeof(int)));</a>
<a name="ln232">    close_memory(sync, sizeof(sync_t));</a>
<a name="ln233">    </a>
<a name="ln234">    return 0;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
</code></pre>
<div class="balloon" rel="75"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'printf' function. The SIGNED integer type argument is expected.</p></div>
<div class="balloon" rel="75"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'printf' function. The SIGNED integer type argument is expected.</p></div>
<div class="balloon" rel="75"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v576/" target="_blank">V576</a> Incorrect format. Consider checking the sixth actual argument of the 'printf' function. The SIGNED integer type argument is expected.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>