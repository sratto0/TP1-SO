<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>player.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">#include &quot;player.h&quot;</a>
<a name="ln2"> </a>
<a name="ln3">int main(int argc, char *argv[]) {</a>
<a name="ln4">  if (argc &lt; 2) {</a>
<a name="ln5">    fprintf(stderr, &quot;Using: %s &lt;player_id&gt;\n&quot;, argv[0]);</a>
<a name="ln6">    return 1;</a>
<a name="ln7">  }</a>
<a name="ln8"> </a>
<a name="ln9">  game_t *game = open_game_memory();</a>
<a name="ln10">  sync_t *sync = open_sync_memory();</a>
<a name="ln11"> </a>
<a name="ln12">  int player_id = 0;</a>
<a name="ln13">  int pid_p = getpid();</a>
<a name="ln14">  while (player_id &lt; game-&gt;player_count) {</a>
<a name="ln15">    if (game-&gt;players[player_id].process_id == pid_p) {</a>
<a name="ln16">      break;</a>
<a name="ln17">    }</a>
<a name="ln18">    player_id++;</a>
<a name="ln19">  }</a>
<a name="ln20"> </a>
<a name="ln21">  // for (int i=0; game-&gt;players[i].process_id != NULL; i++) {</a>
<a name="ln22">  //   if (game-&gt;players[i].process_id == pid_p) {</a>
<a name="ln23">  //     player_id = i + 1;</a>
<a name="ln24">  //     break;</a>
<a name="ln25">  //   }</a>
<a name="ln26">  // }</a>
<a name="ln27"> </a>
<a name="ln28">  if (player_id &lt; 0 || player_id &gt;= game-&gt;player_count) {</a>
<a name="ln29">    fprintf(stderr, &quot;Error: ID de jugador %d no válido. Rango válido: 0-%d\n&quot;,</a>
<a name="ln30">            player_id, game-&gt;player_count - 1);</a>
<a name="ln31">    return 1;</a>
<a name="ln32">  }</a>
<a name="ln33"> </a>
<a name="ln34">  while (true) {</a>
<a name="ln35"> </a>
<a name="ln36">    if (sem_wait(&amp;sync-&gt;writer_lock) == -1) {</a>
<a name="ln37">        perror(&quot;sem_wait writer_lock&quot;);</a>
<a name="ln38">        break;</a>
<a name="ln39">    }</a>
<a name="ln40">    </a>
<a name="ln41">    if (sem_post(&amp;sync-&gt;writer_lock) == -1) {</a>
<a name="ln42">        perror(&quot;sem_post writer_lock&quot;);</a>
<a name="ln43">        break;</a>
<a name="ln44">    }</a>
<a name="ln45"> </a>
<a name="ln46">    if (sem_wait(&amp;sync-&gt;players_ready[player_id]) == -1) {</a>
<a name="ln47">      if (errno == EINTR)</a>
<a name="ln48">        continue;</a>
<a name="ln49">      perror(&quot;sem_wait players_ready&quot;);</a>
<a name="ln50">      break;</a>
<a name="ln51">    }</a>
<a name="ln52"> </a>
<a name="ln53">    if (game-&gt;finished) {</a>
<a name="ln54">      break;</a>
<a name="ln55">    }</a>
<a name="ln56"> </a>
<a name="ln57">    if (sem_wait(&amp;sync-&gt;readers_mutex) == -1) {</a>
<a name="ln58">      perror(&quot;sem_wait readers_mutex&quot;);</a>
<a name="ln59">      break;</a>
<a name="ln60">    }</a>
<a name="ln61"> </a>
<a name="ln62">    sync-&gt;readers_count++;</a>
<a name="ln63">    if (sync-&gt;readers_count == 1) {</a>
<a name="ln64">      if (sem_wait(&amp;sync-&gt;state_lock) == -1) {</a>
<a name="ln65">        perror(&quot;sem_wait state_lock&quot;);</a>
<a name="ln66">        break;</a>
<a name="ln67">      }</a>
<a name="ln68">    }</a>
<a name="ln69"> </a>
<a name="ln70">    if (sem_post(&amp;sync-&gt;readers_mutex) == -1) {</a>
<a name="ln71">      perror(&quot;sem_post readers_mutex&quot;);</a>
<a name="ln72">      break;</a>
<a name="ln73">    }</a>
<a name="ln74"> </a>
<a name="ln75">    unsigned char move = choose_move(player_id); //Esto está en el lugar incorrecto. Estamos eligiendo el movimiento antes de liberar el mutex del juego. Acá sólo se debería consultar el estado y no elegir el movimiento</a>
<a name="ln76"> </a>
<a name="ln77">    if (sem_wait(&amp;sync-&gt;readers_mutex) == -1) {</a>
<a name="ln78">      perror(&quot;sem_wait readers_mutex&quot;);</a>
<a name="ln79">      break;</a>
<a name="ln80">    }</a>
<a name="ln81"> </a>
<a name="ln82">    sync-&gt;readers_count--;</a>
<a name="ln83">    if (sync-&gt;readers_count == 0) {</a>
<a name="ln84">      if (sem_post(&amp;sync-&gt;state_lock) == -1) {</a>
<a name="ln85">        perror(&quot;sem_post state_lock&quot;);</a>
<a name="ln86">        break;</a>
<a name="ln87">      }</a>
<a name="ln88">    }</a>
<a name="ln89"> </a>
<a name="ln90">    if (sem_post(&amp;sync-&gt;readers_mutex) == -1) {</a>
<a name="ln91">      perror(&quot;sem_post readers_mutex&quot;);</a>
<a name="ln92">      break;</a>
<a name="ln93">    }</a>
<a name="ln94"> </a>
<a name="ln95">    write(1, &amp;move, sizeof(move));</a>
<a name="ln96">  }</a>
<a name="ln97"> </a>
<a name="ln98">  return 0;</a>
<a name="ln99">}</a>
<a name="ln100"> </a>
<a name="ln101">// Función para elegir el mejor movimiento basado en los valores de celdas adyacentes</a>
<a name="ln102">unsigned char choose_move(int player_id) { </a>
<a name="ln103">    game_t *game = open_game_memory();</a>
<a name="ln104">    int x = game-&gt;players[player_id].x;</a>
<a name="ln105">    int y = game-&gt;players[player_id].y;</a>
<a name="ln106">    int best_value = -1;</a>
<a name="ln107">    unsigned char best_direction = 0;</a>
<a name="ln108">    </a>
<a name="ln109">    // Arreglos para calcular las 8 direcciones</a>
<a name="ln110">    int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}; // Cambios en x</a>
<a name="ln111">    int dy[] = {-1, -1, 0, 1, 1, 1, 0, -1}; // Cambios en y</a>
<a name="ln112">    </a>
<a name="ln113">    // Evaluar cada dirección</a>
<a name="ln114">    for (unsigned char dir = 0; dir &lt; 8; dir++) {</a>
<a name="ln115">        int new_x = x + dx[dir];</a>
<a name="ln116">        int new_y = y + dy[dir];</a>
<a name="ln117">        </a>
<a name="ln118">        // Verificar si la nueva posición está dentro del tablero</a>
<a name="ln119">        if (new_x &gt;= 0 &amp;&amp; new_x &lt; game-&gt;width &amp;&amp; new_y &gt;= 0 &amp;&amp; new_y &lt; game-&gt;height) {</a>
<a name="ln120">            int cell_value = game-&gt;board[new_y * game-&gt;width + new_x];</a>
<a name="ln121">            </a>
<a name="ln122">            // Si encontramos un valor mayor, actualizamos la mejor dirección</a>
<a name="ln123">            if (cell_value &gt; best_value) {</a>
<a name="ln124">                best_value = cell_value;</a>
<a name="ln125">                best_direction = dir;</a>
<a name="ln126">            }</a>
<a name="ln127">        }</a>
<a name="ln128">    }</a>
<a name="ln129">    </a>
<a name="ln130">    // Imprimir información de depuración</a>
<a name="ln131">    printf(&quot;Jugador %d en (%d,%d) eligió dirección %d con valor %d\n&quot;, </a>
<a name="ln132">           player_id, x, y, best_direction, best_value);</a>
<a name="ln133">    </a>
<a name="ln134">    return best_direction;</a>
<a name="ln135">}</a>
</code></pre>
<div class="balloon" rel="1"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v009/" target="_blank">V009</a> To use free version of PVS-Studio, source code files are required to start with a special comment.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>